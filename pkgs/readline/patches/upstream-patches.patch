--- src/callback.c.orig
+++ src/callback.c
@@ -115,7 +115,10 @@ rl_callback_handler_install (const char *prompt, rl_vcpfunc_t *linefunc)
 #define CALLBACK_READ_RETURN() \
   do { \
     if (rl_persistent_signal_handlers == 0) \
-      rl_clear_signals (); \
+      { \
+        rl_clear_signals (); \
+        if (_rl_caught_signal) _rl_signal_handler (_rl_caught_signal); \
+      } \
     return; \
   } while (0)
 #else
--- src/colors.c.orig
+++ src/colors.c
@@ -73,7 +73,7 @@
 static bool is_colored (enum indicator_no type);
 static void restore_default_color (void);
 
-#define RL_COLOR_PREFIX_EXTENSION	"readline-colored-completion-prefix"
+#define RL_COLOR_PREFIX_EXTENSION	".readline-colored-completion-prefix"
 
 COLOR_EXT_TYPE *_rl_color_ext_list = 0;
 
--- src/display.c.orig
+++ src/display.c
@@ -2683,11 +2683,8 @@ rl_forced_update_display (void)
   register char *temp;
 
   if (visible_line)
-    {
-      temp = visible_line;
-      while (*temp)
-	*temp++ = '\0';
-    }
+    memset (visible_line, 0, line_size);
+
   rl_on_new_line ();
   forced_display++;
   (*rl_redisplay_function) ();
@@ -3341,9 +3338,9 @@ _rl_update_final (void)
       puts_face (&last_line[_rl_screenwidth - 1 + woff],
 		 &last_face[_rl_screenwidth - 1 + woff], 1);
     }
-  _rl_vis_botlin = 0;
-  if (botline_length > 0 || _rl_last_c_pos > 0)
+  if ((_rl_vis_botlin == 0 && botline_length == 0) || botline_length > 0 || _rl_last_c_pos > 0)
     rl_crlf ();
+  _rl_vis_botlin = 0;
   fflush (rl_outstream);
   rl_display_fixed++;
 }
--- src/input.c.orig
+++ src/input.c
@@ -151,7 +151,9 @@ int rl_timeout_remaining (unsigned int *, unsigned int *);
 
 int _rl_timeout_init (void);
 int _rl_timeout_sigalrm_handler (void);
+#if defined (RL_TIMEOUT_USE_SELECT)
 int _rl_timeout_select (int, fd_set *, fd_set *, fd_set *, const struct timeval *, const sigset_t *);
+#endif
 
 static void _rl_timeout_handle (void);
 #if defined (RL_TIMEOUT_USE_SIGALRM)
@@ -248,7 +250,7 @@ rl_gather_tyi (void)
   register int tem, result;
   int chars_avail, k;
   char input;
-#if defined(HAVE_SELECT)
+#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)
   fd_set readfds, exceptfds;
   struct timeval timeout;
 #endif
@@ -802,10 +804,10 @@ rl_read_key (void)
 int
 rl_getc (FILE *stream)
 {
-  int result;
+  int result, ostate, osig;
   unsigned char c;
   int fd;
-#if defined (HAVE_PSELECT)
+#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)
   sigset_t empty_set;
   fd_set readfds;
 #endif
@@ -813,8 +815,22 @@ rl_getc (FILE *stream)
   fd = fileno (stream);
   while (1)
     {
+      osig = _rl_caught_signal;
+      ostate = rl_readline_state;
+
       RL_CHECK_SIGNALS ();
 
+#if defined (READLINE_CALLBACKS)
+      /* Do signal handling post-processing here, but just in callback mode
+	 for right now because the signal cleanup can change some of the
+	 callback state, and we need to either let the application have a
+	 chance to react or abort some current operation that gets cleaned
+	 up by rl_callback_sigcleanup(). If not, we'll just run through the
+	 loop again. */
+      if (osig != 0 && (ostate & RL_STATE_CALLBACK))
+	goto postproc_signal;
+#endif
+
       /* We know at this point that _rl_caught_signal == 0 */
 
 #if defined (__MINGW32__)
@@ -878,6 +894,9 @@ rl_getc (FILE *stream)
 /* fprintf(stderr, "rl_getc: result = %d errno = %d\n", result, errno); */
 
 handle_error:
+      osig = _rl_caught_signal;
+      ostate = rl_readline_state;
+
       /* If the error that we received was EINTR, then try again,
 	 this is simply an interrupted system call to read ().  We allow
 	 the read to be interrupted if we caught SIGHUP, SIGTERM, or any
@@ -918,8 +937,17 @@ handle_error:
         RL_CHECK_SIGNALS ();
 #endif  /* SIGALRM */
 
+postproc_signal:
+      /* POSIX says read(2)/pselect(2)/select(2) don't return EINTR for any
+	 reason other than being interrupted by a signal, so we can safely
+	 call the application's signal event hook. */
       if (rl_signal_event_hook)
 	(*rl_signal_event_hook) ();
+#if defined (READLINE_CALLBACKS)
+      else if (osig == SIGINT && (ostate & RL_STATE_CALLBACK) && (ostate & (RL_STATE_ISEARCH|RL_STATE_NSEARCH|RL_STATE_NUMERICARG)))
+        /* just these cases for now */
+        _rl_abort_internal ();
+#endif
     }
 }
 
--- src/nls.c.orig
+++ src/nls.c
@@ -141,6 +141,10 @@ _rl_init_locale (void)
   if (lspec == 0)
     lspec = "";
   ret = setlocale (LC_CTYPE, lspec);	/* ok, since it does not change locale */
+  if (ret == 0 || *ret == 0)
+    ret = setlocale (LC_CTYPE, (char *)NULL);
+  if (ret == 0 || *ret == 0)
+    ret = RL_DEFAULT_LOCALE;
 #else
   ret = (lspec == 0 || *lspec == 0) ? RL_DEFAULT_LOCALE : lspec;
 #endif
--- src/patchlevel.orig
+++ src/patchlevel
@@ -1,3 +1,3 @@
 # Do not edit -- exists only for use by patch
 
-0
+7
